<!-- livebook:{"persist_outputs":true} -->

# Advent of Code Day 8

## Setup

```elixir
test_input = """
be cfbegad cbdgef fgaecd cgeb fdcge agebfd fecdb fabcd edb | fdgacbe cefdb cefbgd gcbe
edbfga begcd cbg gc gcadebf fbgde acbgfd abcde gfcbed gfec | fcgedb cgb dgebacf gc
fgaebd cg bdaec gdafb agbcfd gdcbef bgcad gfac gcb cdgabef | cg cg fdcagb cbg
fbegcd cbd adcefb dageb afcb bc aefdc ecdab fgdeca fcdbega | efabcd cedba gadfec cb
aecbfdg fbg gf bafeg dbefa fcge gcbea fcaegb dgceab fcbdga | gecf egdcabf bgf bfgea
fgeab ca afcebg bdacfeg cfaedg gcfdb baec bfadeg bafgc acf | gebdcfa ecba ca fadegcb
dbcfg fgd bdegcaf fgec aegbdf ecdfab fbedc dacgb gdcebf gf | cefg dcbef fcge gbcadfe
bdfegc cbegaf gecbf dfcage bdacg ed bedf ced adcbefg gebcd | ed bcgafe cdgba cbgef
egadfb cdbfeg cegd fecab cgb gbdefca cg fgcdab egfdb bfceg | gbdfcae bgc cg cgb
gcafb gcf dcaebfg ecagb gf abcdeg gaef cafbge fdbac fegbdc | fgae cfgab fg bagce
"""

defmodule Setup do
  def parse(input) when is_binary(input) do
    input
    |> String.split("\n", trim: true)
    |> Enum.map(fn line ->
      line
      |> String.split("|")
      |> Enum.map(&String.split(&1, " ", trim: true))
      |> List.to_tuple()
    end)
  end
end
```

```output
[
  {["be", "cfbegad", "cbdgef", "fgaecd", "cgeb", "fdcge", "agebfd", "fecdb", "fabcd", "edb"],
   ["fdgacbe", "cefdb", "cefbgd", "gcbe"]},
  {["edbfga", "begcd", "cbg", "gc", "gcadebf", "fbgde", "acbgfd", "abcde", "gfcbed", "gfec"],
   ["fcgedb", "cgb", "dgebacf", "gc"]},
  {["fgaebd", "cg", "bdaec", "gdafb", "agbcfd", "gdcbef", "bgcad", "gfac", "gcb", "cdgabef"],
   ["cg", "cg", "fdcagb", "cbg"]},
  {["fbegcd", "cbd", "adcefb", "dageb", "afcb", "bc", "aefdc", "ecdab", "fgdeca", "fcdbega"],
   ["efabcd", "cedba", "gadfec", "cb"]},
  {["aecbfdg", "fbg", "gf", "bafeg", "dbefa", "fcge", "gcbea", "fcaegb", "dgceab", "fcbdga"],
   ["gecf", "egdcabf", "bgf", "bfgea"]},
  {["fgeab", "ca", "afcebg", "bdacfeg", "cfaedg", "gcfdb", "baec", "bfadeg", "bafgc", "acf"],
   ["gebdcfa", "ecba", "ca", "fadegcb"]},
  {["dbcfg", "fgd", "bdegcaf", "fgec", "aegbdf", "ecdfab", "fbedc", "dacgb", "gdcebf", "gf"],
   ["cefg", "dcbef", "fcge", "gbcadfe"]},
  {["bdfegc", "cbegaf", "gecbf", "dfcage", "bdacg", "ed", "bedf", "ced", "adcbefg", "gebcd"],
   ["ed", "bcgafe", "cdgba", "cbgef"]},
  {["egadfb", "cdbfeg", "cegd", "fecab", "cgb", "gbdefca", "cg", "fgcdab", "egfdb", "bfceg"],
   ["gbdfcae", "bgc", "cg", "cgb"]},
  {["gcafb", "gcf", "dcaebfg", "ecagb", "gf", "abcdeg", "gaef", "cafbge", "fdbac", "fegbdc"],
   ["fgae", "cfgab", "fg", "bagce"]}
]
```

## Part 1

```elixir
defmodule DayEightPart1 do
  def count(input) do
    input
    |> Enum.map(fn {_signal, output} ->
      Enum.filter(output, &(String.length(&1) in [2, 3, 4, 7]))
    end)
    |> List.flatten()
    |> Enum.count()
  end
end

test_input
|> Setup.parse()
|> DayEightPart1.count()
```

```output
26
```
